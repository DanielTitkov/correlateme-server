// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/DanielTitkov/correlateme-server/internal/repository/entgo/ent/anomaly"
	"github.com/DanielTitkov/correlateme-server/internal/repository/entgo/ent/detectionjob"
	"github.com/DanielTitkov/correlateme-server/internal/repository/entgo/ent/detectionjobinstance"
	"github.com/DanielTitkov/correlateme-server/internal/repository/entgo/ent/predicate"
	"github.com/DanielTitkov/correlateme-server/internal/repository/entgo/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAnomaly              = "Anomaly"
	TypeDetectionJob         = "DetectionJob"
	TypeDetectionJobInstance = "DetectionJobInstance"
	TypeUser                 = "User"
)

// AnomalyMutation represents an operation that mutates the Anomaly nodes in the graph.
type AnomalyMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	create_time                   *time.Time
	update_time                   *time.Time
	_type                         *string
	value                         *float64
	addvalue                      *float64
	processed                     *bool
	period_start                  *time.Time
	period_end                    *time.Time
	clearedFields                 map[string]struct{}
	detection_job_instance        *int
	cleareddetection_job_instance bool
	done                          bool
	oldValue                      func(context.Context) (*Anomaly, error)
	predicates                    []predicate.Anomaly
}

var _ ent.Mutation = (*AnomalyMutation)(nil)

// anomalyOption allows management of the mutation configuration using functional options.
type anomalyOption func(*AnomalyMutation)

// newAnomalyMutation creates new mutation for the Anomaly entity.
func newAnomalyMutation(c config, op Op, opts ...anomalyOption) *AnomalyMutation {
	m := &AnomalyMutation{
		config:        c,
		op:            op,
		typ:           TypeAnomaly,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAnomalyID sets the ID field of the mutation.
func withAnomalyID(id int) anomalyOption {
	return func(m *AnomalyMutation) {
		var (
			err   error
			once  sync.Once
			value *Anomaly
		)
		m.oldValue = func(ctx context.Context) (*Anomaly, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Anomaly.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAnomaly sets the old Anomaly of the mutation.
func withAnomaly(node *Anomaly) anomalyOption {
	return func(m *AnomalyMutation) {
		m.oldValue = func(context.Context) (*Anomaly, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AnomalyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AnomalyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *AnomalyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *AnomalyMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *AnomalyMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *AnomalyMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *AnomalyMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *AnomalyMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *AnomalyMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetType sets the "type" field.
func (m *AnomalyMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *AnomalyMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AnomalyMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *AnomalyMutation) SetValue(f float64) {
	m.value = &f
	m.addvalue = nil
}

// Value returns the value of the "value" field in the mutation.
func (m *AnomalyMutation) Value() (r float64, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// AddValue adds f to the "value" field.
func (m *AnomalyMutation) AddValue(f float64) {
	if m.addvalue != nil {
		*m.addvalue += f
	} else {
		m.addvalue = &f
	}
}

// AddedValue returns the value that was added to the "value" field in this mutation.
func (m *AnomalyMutation) AddedValue() (r float64, exists bool) {
	v := m.addvalue
	if v == nil {
		return
	}
	return *v, true
}

// ResetValue resets all changes to the "value" field.
func (m *AnomalyMutation) ResetValue() {
	m.value = nil
	m.addvalue = nil
}

// SetProcessed sets the "processed" field.
func (m *AnomalyMutation) SetProcessed(b bool) {
	m.processed = &b
}

// Processed returns the value of the "processed" field in the mutation.
func (m *AnomalyMutation) Processed() (r bool, exists bool) {
	v := m.processed
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessed returns the old "processed" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldProcessed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProcessed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProcessed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessed: %w", err)
	}
	return oldValue.Processed, nil
}

// ResetProcessed resets all changes to the "processed" field.
func (m *AnomalyMutation) ResetProcessed() {
	m.processed = nil
}

// SetPeriodStart sets the "period_start" field.
func (m *AnomalyMutation) SetPeriodStart(t time.Time) {
	m.period_start = &t
}

// PeriodStart returns the value of the "period_start" field in the mutation.
func (m *AnomalyMutation) PeriodStart() (r time.Time, exists bool) {
	v := m.period_start
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodStart returns the old "period_start" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldPeriodStart(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeriodStart is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeriodStart requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodStart: %w", err)
	}
	return oldValue.PeriodStart, nil
}

// ResetPeriodStart resets all changes to the "period_start" field.
func (m *AnomalyMutation) ResetPeriodStart() {
	m.period_start = nil
}

// SetPeriodEnd sets the "period_end" field.
func (m *AnomalyMutation) SetPeriodEnd(t time.Time) {
	m.period_end = &t
}

// PeriodEnd returns the value of the "period_end" field in the mutation.
func (m *AnomalyMutation) PeriodEnd() (r time.Time, exists bool) {
	v := m.period_end
	if v == nil {
		return
	}
	return *v, true
}

// OldPeriodEnd returns the old "period_end" field's value of the Anomaly entity.
// If the Anomaly object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AnomalyMutation) OldPeriodEnd(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPeriodEnd is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPeriodEnd requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPeriodEnd: %w", err)
	}
	return oldValue.PeriodEnd, nil
}

// ResetPeriodEnd resets all changes to the "period_end" field.
func (m *AnomalyMutation) ResetPeriodEnd() {
	m.period_end = nil
}

// SetDetectionJobInstanceID sets the "detection_job_instance" edge to the DetectionJobInstance entity by id.
func (m *AnomalyMutation) SetDetectionJobInstanceID(id int) {
	m.detection_job_instance = &id
}

// ClearDetectionJobInstance clears the "detection_job_instance" edge to the DetectionJobInstance entity.
func (m *AnomalyMutation) ClearDetectionJobInstance() {
	m.cleareddetection_job_instance = true
}

// DetectionJobInstanceCleared returns if the "detection_job_instance" edge to the DetectionJobInstance entity was cleared.
func (m *AnomalyMutation) DetectionJobInstanceCleared() bool {
	return m.cleareddetection_job_instance
}

// DetectionJobInstanceID returns the "detection_job_instance" edge ID in the mutation.
func (m *AnomalyMutation) DetectionJobInstanceID() (id int, exists bool) {
	if m.detection_job_instance != nil {
		return *m.detection_job_instance, true
	}
	return
}

// DetectionJobInstanceIDs returns the "detection_job_instance" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DetectionJobInstanceID instead. It exists only for internal usage by the builders.
func (m *AnomalyMutation) DetectionJobInstanceIDs() (ids []int) {
	if id := m.detection_job_instance; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDetectionJobInstance resets all changes to the "detection_job_instance" edge.
func (m *AnomalyMutation) ResetDetectionJobInstance() {
	m.detection_job_instance = nil
	m.cleareddetection_job_instance = false
}

// Op returns the operation name.
func (m *AnomalyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Anomaly).
func (m *AnomalyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AnomalyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.create_time != nil {
		fields = append(fields, anomaly.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, anomaly.FieldUpdateTime)
	}
	if m._type != nil {
		fields = append(fields, anomaly.FieldType)
	}
	if m.value != nil {
		fields = append(fields, anomaly.FieldValue)
	}
	if m.processed != nil {
		fields = append(fields, anomaly.FieldProcessed)
	}
	if m.period_start != nil {
		fields = append(fields, anomaly.FieldPeriodStart)
	}
	if m.period_end != nil {
		fields = append(fields, anomaly.FieldPeriodEnd)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AnomalyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case anomaly.FieldCreateTime:
		return m.CreateTime()
	case anomaly.FieldUpdateTime:
		return m.UpdateTime()
	case anomaly.FieldType:
		return m.GetType()
	case anomaly.FieldValue:
		return m.Value()
	case anomaly.FieldProcessed:
		return m.Processed()
	case anomaly.FieldPeriodStart:
		return m.PeriodStart()
	case anomaly.FieldPeriodEnd:
		return m.PeriodEnd()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AnomalyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case anomaly.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case anomaly.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case anomaly.FieldType:
		return m.OldType(ctx)
	case anomaly.FieldValue:
		return m.OldValue(ctx)
	case anomaly.FieldProcessed:
		return m.OldProcessed(ctx)
	case anomaly.FieldPeriodStart:
		return m.OldPeriodStart(ctx)
	case anomaly.FieldPeriodEnd:
		return m.OldPeriodEnd(ctx)
	}
	return nil, fmt.Errorf("unknown Anomaly field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnomalyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case anomaly.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case anomaly.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case anomaly.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case anomaly.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case anomaly.FieldProcessed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessed(v)
		return nil
	case anomaly.FieldPeriodStart:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodStart(v)
		return nil
	case anomaly.FieldPeriodEnd:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPeriodEnd(v)
		return nil
	}
	return fmt.Errorf("unknown Anomaly field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AnomalyMutation) AddedFields() []string {
	var fields []string
	if m.addvalue != nil {
		fields = append(fields, anomaly.FieldValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AnomalyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case anomaly.FieldValue:
		return m.AddedValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AnomalyMutation) AddField(name string, value ent.Value) error {
	switch name {
	case anomaly.FieldValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddValue(v)
		return nil
	}
	return fmt.Errorf("unknown Anomaly numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AnomalyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AnomalyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AnomalyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Anomaly nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AnomalyMutation) ResetField(name string) error {
	switch name {
	case anomaly.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case anomaly.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case anomaly.FieldType:
		m.ResetType()
		return nil
	case anomaly.FieldValue:
		m.ResetValue()
		return nil
	case anomaly.FieldProcessed:
		m.ResetProcessed()
		return nil
	case anomaly.FieldPeriodStart:
		m.ResetPeriodStart()
		return nil
	case anomaly.FieldPeriodEnd:
		m.ResetPeriodEnd()
		return nil
	}
	return fmt.Errorf("unknown Anomaly field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AnomalyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.detection_job_instance != nil {
		edges = append(edges, anomaly.EdgeDetectionJobInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AnomalyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case anomaly.EdgeDetectionJobInstance:
		if id := m.detection_job_instance; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AnomalyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AnomalyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AnomalyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareddetection_job_instance {
		edges = append(edges, anomaly.EdgeDetectionJobInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AnomalyMutation) EdgeCleared(name string) bool {
	switch name {
	case anomaly.EdgeDetectionJobInstance:
		return m.cleareddetection_job_instance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AnomalyMutation) ClearEdge(name string) error {
	switch name {
	case anomaly.EdgeDetectionJobInstance:
		m.ClearDetectionJobInstance()
		return nil
	}
	return fmt.Errorf("unknown Anomaly unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AnomalyMutation) ResetEdge(name string) error {
	switch name {
	case anomaly.EdgeDetectionJobInstance:
		m.ResetDetectionJobInstance()
		return nil
	}
	return fmt.Errorf("unknown Anomaly edge %s", name)
}

// DetectionJobMutation represents an operation that mutates the DetectionJob nodes in the graph.
type DetectionJobMutation struct {
	config
	op              Op
	typ             string
	id              *int
	create_time     *time.Time
	update_time     *time.Time
	schedule        *string
	method          *string
	site_id         *string
	metric          *string
	attribute       *string
	time_ago        *string
	time_step       *string
	description     *string
	clearedFields   map[string]struct{}
	instance        map[int]struct{}
	removedinstance map[int]struct{}
	clearedinstance bool
	done            bool
	oldValue        func(context.Context) (*DetectionJob, error)
	predicates      []predicate.DetectionJob
}

var _ ent.Mutation = (*DetectionJobMutation)(nil)

// detectionjobOption allows management of the mutation configuration using functional options.
type detectionjobOption func(*DetectionJobMutation)

// newDetectionJobMutation creates new mutation for the DetectionJob entity.
func newDetectionJobMutation(c config, op Op, opts ...detectionjobOption) *DetectionJobMutation {
	m := &DetectionJobMutation{
		config:        c,
		op:            op,
		typ:           TypeDetectionJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDetectionJobID sets the ID field of the mutation.
func withDetectionJobID(id int) detectionjobOption {
	return func(m *DetectionJobMutation) {
		var (
			err   error
			once  sync.Once
			value *DetectionJob
		)
		m.oldValue = func(ctx context.Context) (*DetectionJob, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DetectionJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDetectionJob sets the old DetectionJob of the mutation.
func withDetectionJob(node *DetectionJob) detectionjobOption {
	return func(m *DetectionJobMutation) {
		m.oldValue = func(context.Context) (*DetectionJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DetectionJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DetectionJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DetectionJobMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *DetectionJobMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DetectionJobMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DetectionJobMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DetectionJobMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DetectionJobMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DetectionJobMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetSchedule sets the "schedule" field.
func (m *DetectionJobMutation) SetSchedule(s string) {
	m.schedule = &s
}

// Schedule returns the value of the "schedule" field in the mutation.
func (m *DetectionJobMutation) Schedule() (r string, exists bool) {
	v := m.schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldSchedule returns the old "schedule" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldSchedule(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchedule: %w", err)
	}
	return oldValue.Schedule, nil
}

// ClearSchedule clears the value of the "schedule" field.
func (m *DetectionJobMutation) ClearSchedule() {
	m.schedule = nil
	m.clearedFields[detectionjob.FieldSchedule] = struct{}{}
}

// ScheduleCleared returns if the "schedule" field was cleared in this mutation.
func (m *DetectionJobMutation) ScheduleCleared() bool {
	_, ok := m.clearedFields[detectionjob.FieldSchedule]
	return ok
}

// ResetSchedule resets all changes to the "schedule" field.
func (m *DetectionJobMutation) ResetSchedule() {
	m.schedule = nil
	delete(m.clearedFields, detectionjob.FieldSchedule)
}

// SetMethod sets the "method" field.
func (m *DetectionJobMutation) SetMethod(s string) {
	m.method = &s
}

// Method returns the value of the "method" field in the mutation.
func (m *DetectionJobMutation) Method() (r string, exists bool) {
	v := m.method
	if v == nil {
		return
	}
	return *v, true
}

// OldMethod returns the old "method" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMethod: %w", err)
	}
	return oldValue.Method, nil
}

// ResetMethod resets all changes to the "method" field.
func (m *DetectionJobMutation) ResetMethod() {
	m.method = nil
}

// SetSiteID sets the "site_id" field.
func (m *DetectionJobMutation) SetSiteID(s string) {
	m.site_id = &s
}

// SiteID returns the value of the "site_id" field in the mutation.
func (m *DetectionJobMutation) SiteID() (r string, exists bool) {
	v := m.site_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteID returns the old "site_id" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldSiteID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSiteID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSiteID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteID: %w", err)
	}
	return oldValue.SiteID, nil
}

// ResetSiteID resets all changes to the "site_id" field.
func (m *DetectionJobMutation) ResetSiteID() {
	m.site_id = nil
}

// SetMetric sets the "metric" field.
func (m *DetectionJobMutation) SetMetric(s string) {
	m.metric = &s
}

// Metric returns the value of the "metric" field in the mutation.
func (m *DetectionJobMutation) Metric() (r string, exists bool) {
	v := m.metric
	if v == nil {
		return
	}
	return *v, true
}

// OldMetric returns the old "metric" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldMetric(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMetric is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMetric requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetric: %w", err)
	}
	return oldValue.Metric, nil
}

// ResetMetric resets all changes to the "metric" field.
func (m *DetectionJobMutation) ResetMetric() {
	m.metric = nil
}

// SetAttribute sets the "attribute" field.
func (m *DetectionJobMutation) SetAttribute(s string) {
	m.attribute = &s
}

// Attribute returns the value of the "attribute" field in the mutation.
func (m *DetectionJobMutation) Attribute() (r string, exists bool) {
	v := m.attribute
	if v == nil {
		return
	}
	return *v, true
}

// OldAttribute returns the old "attribute" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldAttribute(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAttribute is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAttribute requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAttribute: %w", err)
	}
	return oldValue.Attribute, nil
}

// ResetAttribute resets all changes to the "attribute" field.
func (m *DetectionJobMutation) ResetAttribute() {
	m.attribute = nil
}

// SetTimeAgo sets the "time_ago" field.
func (m *DetectionJobMutation) SetTimeAgo(s string) {
	m.time_ago = &s
}

// TimeAgo returns the value of the "time_ago" field in the mutation.
func (m *DetectionJobMutation) TimeAgo() (r string, exists bool) {
	v := m.time_ago
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeAgo returns the old "time_ago" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldTimeAgo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeAgo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeAgo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeAgo: %w", err)
	}
	return oldValue.TimeAgo, nil
}

// ResetTimeAgo resets all changes to the "time_ago" field.
func (m *DetectionJobMutation) ResetTimeAgo() {
	m.time_ago = nil
}

// SetTimeStep sets the "time_step" field.
func (m *DetectionJobMutation) SetTimeStep(s string) {
	m.time_step = &s
}

// TimeStep returns the value of the "time_step" field in the mutation.
func (m *DetectionJobMutation) TimeStep() (r string, exists bool) {
	v := m.time_step
	if v == nil {
		return
	}
	return *v, true
}

// OldTimeStep returns the old "time_step" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldTimeStep(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTimeStep is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTimeStep requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTimeStep: %w", err)
	}
	return oldValue.TimeStep, nil
}

// ResetTimeStep resets all changes to the "time_step" field.
func (m *DetectionJobMutation) ResetTimeStep() {
	m.time_step = nil
}

// SetDescription sets the "description" field.
func (m *DetectionJobMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DetectionJobMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DetectionJob entity.
// If the DetectionJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DetectionJobMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[detectionjob.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DetectionJobMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[detectionjob.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DetectionJobMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, detectionjob.FieldDescription)
}

// AddInstanceIDs adds the "instance" edge to the DetectionJobInstance entity by ids.
func (m *DetectionJobMutation) AddInstanceIDs(ids ...int) {
	if m.instance == nil {
		m.instance = make(map[int]struct{})
	}
	for i := range ids {
		m.instance[ids[i]] = struct{}{}
	}
}

// ClearInstance clears the "instance" edge to the DetectionJobInstance entity.
func (m *DetectionJobMutation) ClearInstance() {
	m.clearedinstance = true
}

// InstanceCleared returns if the "instance" edge to the DetectionJobInstance entity was cleared.
func (m *DetectionJobMutation) InstanceCleared() bool {
	return m.clearedinstance
}

// RemoveInstanceIDs removes the "instance" edge to the DetectionJobInstance entity by IDs.
func (m *DetectionJobMutation) RemoveInstanceIDs(ids ...int) {
	if m.removedinstance == nil {
		m.removedinstance = make(map[int]struct{})
	}
	for i := range ids {
		m.removedinstance[ids[i]] = struct{}{}
	}
}

// RemovedInstance returns the removed IDs of the "instance" edge to the DetectionJobInstance entity.
func (m *DetectionJobMutation) RemovedInstanceIDs() (ids []int) {
	for id := range m.removedinstance {
		ids = append(ids, id)
	}
	return
}

// InstanceIDs returns the "instance" edge IDs in the mutation.
func (m *DetectionJobMutation) InstanceIDs() (ids []int) {
	for id := range m.instance {
		ids = append(ids, id)
	}
	return
}

// ResetInstance resets all changes to the "instance" edge.
func (m *DetectionJobMutation) ResetInstance() {
	m.instance = nil
	m.clearedinstance = false
	m.removedinstance = nil
}

// Op returns the operation name.
func (m *DetectionJobMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DetectionJob).
func (m *DetectionJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DetectionJobMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.create_time != nil {
		fields = append(fields, detectionjob.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, detectionjob.FieldUpdateTime)
	}
	if m.schedule != nil {
		fields = append(fields, detectionjob.FieldSchedule)
	}
	if m.method != nil {
		fields = append(fields, detectionjob.FieldMethod)
	}
	if m.site_id != nil {
		fields = append(fields, detectionjob.FieldSiteID)
	}
	if m.metric != nil {
		fields = append(fields, detectionjob.FieldMetric)
	}
	if m.attribute != nil {
		fields = append(fields, detectionjob.FieldAttribute)
	}
	if m.time_ago != nil {
		fields = append(fields, detectionjob.FieldTimeAgo)
	}
	if m.time_step != nil {
		fields = append(fields, detectionjob.FieldTimeStep)
	}
	if m.description != nil {
		fields = append(fields, detectionjob.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DetectionJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case detectionjob.FieldCreateTime:
		return m.CreateTime()
	case detectionjob.FieldUpdateTime:
		return m.UpdateTime()
	case detectionjob.FieldSchedule:
		return m.Schedule()
	case detectionjob.FieldMethod:
		return m.Method()
	case detectionjob.FieldSiteID:
		return m.SiteID()
	case detectionjob.FieldMetric:
		return m.Metric()
	case detectionjob.FieldAttribute:
		return m.Attribute()
	case detectionjob.FieldTimeAgo:
		return m.TimeAgo()
	case detectionjob.FieldTimeStep:
		return m.TimeStep()
	case detectionjob.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DetectionJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case detectionjob.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case detectionjob.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case detectionjob.FieldSchedule:
		return m.OldSchedule(ctx)
	case detectionjob.FieldMethod:
		return m.OldMethod(ctx)
	case detectionjob.FieldSiteID:
		return m.OldSiteID(ctx)
	case detectionjob.FieldMetric:
		return m.OldMetric(ctx)
	case detectionjob.FieldAttribute:
		return m.OldAttribute(ctx)
	case detectionjob.FieldTimeAgo:
		return m.OldTimeAgo(ctx)
	case detectionjob.FieldTimeStep:
		return m.OldTimeStep(ctx)
	case detectionjob.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown DetectionJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case detectionjob.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case detectionjob.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case detectionjob.FieldSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchedule(v)
		return nil
	case detectionjob.FieldMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMethod(v)
		return nil
	case detectionjob.FieldSiteID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteID(v)
		return nil
	case detectionjob.FieldMetric:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetric(v)
		return nil
	case detectionjob.FieldAttribute:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAttribute(v)
		return nil
	case detectionjob.FieldTimeAgo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeAgo(v)
		return nil
	case detectionjob.FieldTimeStep:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTimeStep(v)
		return nil
	case detectionjob.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DetectionJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DetectionJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DetectionJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DetectionJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(detectionjob.FieldSchedule) {
		fields = append(fields, detectionjob.FieldSchedule)
	}
	if m.FieldCleared(detectionjob.FieldDescription) {
		fields = append(fields, detectionjob.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DetectionJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DetectionJobMutation) ClearField(name string) error {
	switch name {
	case detectionjob.FieldSchedule:
		m.ClearSchedule()
		return nil
	case detectionjob.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown DetectionJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DetectionJobMutation) ResetField(name string) error {
	switch name {
	case detectionjob.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case detectionjob.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case detectionjob.FieldSchedule:
		m.ResetSchedule()
		return nil
	case detectionjob.FieldMethod:
		m.ResetMethod()
		return nil
	case detectionjob.FieldSiteID:
		m.ResetSiteID()
		return nil
	case detectionjob.FieldMetric:
		m.ResetMetric()
		return nil
	case detectionjob.FieldAttribute:
		m.ResetAttribute()
		return nil
	case detectionjob.FieldTimeAgo:
		m.ResetTimeAgo()
		return nil
	case detectionjob.FieldTimeStep:
		m.ResetTimeStep()
		return nil
	case detectionjob.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown DetectionJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DetectionJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.instance != nil {
		edges = append(edges, detectionjob.EdgeInstance)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DetectionJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case detectionjob.EdgeInstance:
		ids := make([]ent.Value, 0, len(m.instance))
		for id := range m.instance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DetectionJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedinstance != nil {
		edges = append(edges, detectionjob.EdgeInstance)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DetectionJobMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case detectionjob.EdgeInstance:
		ids := make([]ent.Value, 0, len(m.removedinstance))
		for id := range m.removedinstance {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DetectionJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedinstance {
		edges = append(edges, detectionjob.EdgeInstance)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DetectionJobMutation) EdgeCleared(name string) bool {
	switch name {
	case detectionjob.EdgeInstance:
		return m.clearedinstance
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DetectionJobMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown DetectionJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DetectionJobMutation) ResetEdge(name string) error {
	switch name {
	case detectionjob.EdgeInstance:
		m.ResetInstance()
		return nil
	}
	return fmt.Errorf("unknown DetectionJob edge %s", name)
}

// DetectionJobInstanceMutation represents an operation that mutates the DetectionJobInstance nodes in the graph.
type DetectionJobInstanceMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	create_time          *time.Time
	update_time          *time.Time
	started_at           *time.Time
	finished_at          *time.Time
	clearedFields        map[string]struct{}
	anomalies            map[int]struct{}
	removedanomalies     map[int]struct{}
	clearedanomalies     bool
	detection_job        *int
	cleareddetection_job bool
	done                 bool
	oldValue             func(context.Context) (*DetectionJobInstance, error)
	predicates           []predicate.DetectionJobInstance
}

var _ ent.Mutation = (*DetectionJobInstanceMutation)(nil)

// detectionjobinstanceOption allows management of the mutation configuration using functional options.
type detectionjobinstanceOption func(*DetectionJobInstanceMutation)

// newDetectionJobInstanceMutation creates new mutation for the DetectionJobInstance entity.
func newDetectionJobInstanceMutation(c config, op Op, opts ...detectionjobinstanceOption) *DetectionJobInstanceMutation {
	m := &DetectionJobInstanceMutation{
		config:        c,
		op:            op,
		typ:           TypeDetectionJobInstance,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDetectionJobInstanceID sets the ID field of the mutation.
func withDetectionJobInstanceID(id int) detectionjobinstanceOption {
	return func(m *DetectionJobInstanceMutation) {
		var (
			err   error
			once  sync.Once
			value *DetectionJobInstance
		)
		m.oldValue = func(ctx context.Context) (*DetectionJobInstance, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DetectionJobInstance.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDetectionJobInstance sets the old DetectionJobInstance of the mutation.
func withDetectionJobInstance(node *DetectionJobInstance) detectionjobinstanceOption {
	return func(m *DetectionJobInstanceMutation) {
		m.oldValue = func(context.Context) (*DetectionJobInstance, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DetectionJobInstanceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DetectionJobInstanceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *DetectionJobInstanceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *DetectionJobInstanceMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *DetectionJobInstanceMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the DetectionJobInstance entity.
// If the DetectionJobInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobInstanceMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *DetectionJobInstanceMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *DetectionJobInstanceMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *DetectionJobInstanceMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the DetectionJobInstance entity.
// If the DetectionJobInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobInstanceMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *DetectionJobInstanceMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetStartedAt sets the "started_at" field.
func (m *DetectionJobInstanceMutation) SetStartedAt(t time.Time) {
	m.started_at = &t
}

// StartedAt returns the value of the "started_at" field in the mutation.
func (m *DetectionJobInstanceMutation) StartedAt() (r time.Time, exists bool) {
	v := m.started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartedAt returns the old "started_at" field's value of the DetectionJobInstance entity.
// If the DetectionJobInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobInstanceMutation) OldStartedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartedAt: %w", err)
	}
	return oldValue.StartedAt, nil
}

// ClearStartedAt clears the value of the "started_at" field.
func (m *DetectionJobInstanceMutation) ClearStartedAt() {
	m.started_at = nil
	m.clearedFields[detectionjobinstance.FieldStartedAt] = struct{}{}
}

// StartedAtCleared returns if the "started_at" field was cleared in this mutation.
func (m *DetectionJobInstanceMutation) StartedAtCleared() bool {
	_, ok := m.clearedFields[detectionjobinstance.FieldStartedAt]
	return ok
}

// ResetStartedAt resets all changes to the "started_at" field.
func (m *DetectionJobInstanceMutation) ResetStartedAt() {
	m.started_at = nil
	delete(m.clearedFields, detectionjobinstance.FieldStartedAt)
}

// SetFinishedAt sets the "finished_at" field.
func (m *DetectionJobInstanceMutation) SetFinishedAt(t time.Time) {
	m.finished_at = &t
}

// FinishedAt returns the value of the "finished_at" field in the mutation.
func (m *DetectionJobInstanceMutation) FinishedAt() (r time.Time, exists bool) {
	v := m.finished_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFinishedAt returns the old "finished_at" field's value of the DetectionJobInstance entity.
// If the DetectionJobInstance object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DetectionJobInstanceMutation) OldFinishedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFinishedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFinishedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFinishedAt: %w", err)
	}
	return oldValue.FinishedAt, nil
}

// ClearFinishedAt clears the value of the "finished_at" field.
func (m *DetectionJobInstanceMutation) ClearFinishedAt() {
	m.finished_at = nil
	m.clearedFields[detectionjobinstance.FieldFinishedAt] = struct{}{}
}

// FinishedAtCleared returns if the "finished_at" field was cleared in this mutation.
func (m *DetectionJobInstanceMutation) FinishedAtCleared() bool {
	_, ok := m.clearedFields[detectionjobinstance.FieldFinishedAt]
	return ok
}

// ResetFinishedAt resets all changes to the "finished_at" field.
func (m *DetectionJobInstanceMutation) ResetFinishedAt() {
	m.finished_at = nil
	delete(m.clearedFields, detectionjobinstance.FieldFinishedAt)
}

// AddAnomalyIDs adds the "anomalies" edge to the Anomaly entity by ids.
func (m *DetectionJobInstanceMutation) AddAnomalyIDs(ids ...int) {
	if m.anomalies == nil {
		m.anomalies = make(map[int]struct{})
	}
	for i := range ids {
		m.anomalies[ids[i]] = struct{}{}
	}
}

// ClearAnomalies clears the "anomalies" edge to the Anomaly entity.
func (m *DetectionJobInstanceMutation) ClearAnomalies() {
	m.clearedanomalies = true
}

// AnomaliesCleared returns if the "anomalies" edge to the Anomaly entity was cleared.
func (m *DetectionJobInstanceMutation) AnomaliesCleared() bool {
	return m.clearedanomalies
}

// RemoveAnomalyIDs removes the "anomalies" edge to the Anomaly entity by IDs.
func (m *DetectionJobInstanceMutation) RemoveAnomalyIDs(ids ...int) {
	if m.removedanomalies == nil {
		m.removedanomalies = make(map[int]struct{})
	}
	for i := range ids {
		m.removedanomalies[ids[i]] = struct{}{}
	}
}

// RemovedAnomalies returns the removed IDs of the "anomalies" edge to the Anomaly entity.
func (m *DetectionJobInstanceMutation) RemovedAnomaliesIDs() (ids []int) {
	for id := range m.removedanomalies {
		ids = append(ids, id)
	}
	return
}

// AnomaliesIDs returns the "anomalies" edge IDs in the mutation.
func (m *DetectionJobInstanceMutation) AnomaliesIDs() (ids []int) {
	for id := range m.anomalies {
		ids = append(ids, id)
	}
	return
}

// ResetAnomalies resets all changes to the "anomalies" edge.
func (m *DetectionJobInstanceMutation) ResetAnomalies() {
	m.anomalies = nil
	m.clearedanomalies = false
	m.removedanomalies = nil
}

// SetDetectionJobID sets the "detection_job" edge to the DetectionJob entity by id.
func (m *DetectionJobInstanceMutation) SetDetectionJobID(id int) {
	m.detection_job = &id
}

// ClearDetectionJob clears the "detection_job" edge to the DetectionJob entity.
func (m *DetectionJobInstanceMutation) ClearDetectionJob() {
	m.cleareddetection_job = true
}

// DetectionJobCleared returns if the "detection_job" edge to the DetectionJob entity was cleared.
func (m *DetectionJobInstanceMutation) DetectionJobCleared() bool {
	return m.cleareddetection_job
}

// DetectionJobID returns the "detection_job" edge ID in the mutation.
func (m *DetectionJobInstanceMutation) DetectionJobID() (id int, exists bool) {
	if m.detection_job != nil {
		return *m.detection_job, true
	}
	return
}

// DetectionJobIDs returns the "detection_job" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DetectionJobID instead. It exists only for internal usage by the builders.
func (m *DetectionJobInstanceMutation) DetectionJobIDs() (ids []int) {
	if id := m.detection_job; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDetectionJob resets all changes to the "detection_job" edge.
func (m *DetectionJobInstanceMutation) ResetDetectionJob() {
	m.detection_job = nil
	m.cleareddetection_job = false
}

// Op returns the operation name.
func (m *DetectionJobInstanceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DetectionJobInstance).
func (m *DetectionJobInstanceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DetectionJobInstanceMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.create_time != nil {
		fields = append(fields, detectionjobinstance.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, detectionjobinstance.FieldUpdateTime)
	}
	if m.started_at != nil {
		fields = append(fields, detectionjobinstance.FieldStartedAt)
	}
	if m.finished_at != nil {
		fields = append(fields, detectionjobinstance.FieldFinishedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DetectionJobInstanceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case detectionjobinstance.FieldCreateTime:
		return m.CreateTime()
	case detectionjobinstance.FieldUpdateTime:
		return m.UpdateTime()
	case detectionjobinstance.FieldStartedAt:
		return m.StartedAt()
	case detectionjobinstance.FieldFinishedAt:
		return m.FinishedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DetectionJobInstanceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case detectionjobinstance.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case detectionjobinstance.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case detectionjobinstance.FieldStartedAt:
		return m.OldStartedAt(ctx)
	case detectionjobinstance.FieldFinishedAt:
		return m.OldFinishedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DetectionJobInstance field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionJobInstanceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case detectionjobinstance.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case detectionjobinstance.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case detectionjobinstance.FieldStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartedAt(v)
		return nil
	case detectionjobinstance.FieldFinishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFinishedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DetectionJobInstance field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DetectionJobInstanceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DetectionJobInstanceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DetectionJobInstanceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DetectionJobInstance numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DetectionJobInstanceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(detectionjobinstance.FieldStartedAt) {
		fields = append(fields, detectionjobinstance.FieldStartedAt)
	}
	if m.FieldCleared(detectionjobinstance.FieldFinishedAt) {
		fields = append(fields, detectionjobinstance.FieldFinishedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DetectionJobInstanceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DetectionJobInstanceMutation) ClearField(name string) error {
	switch name {
	case detectionjobinstance.FieldStartedAt:
		m.ClearStartedAt()
		return nil
	case detectionjobinstance.FieldFinishedAt:
		m.ClearFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown DetectionJobInstance nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DetectionJobInstanceMutation) ResetField(name string) error {
	switch name {
	case detectionjobinstance.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case detectionjobinstance.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case detectionjobinstance.FieldStartedAt:
		m.ResetStartedAt()
		return nil
	case detectionjobinstance.FieldFinishedAt:
		m.ResetFinishedAt()
		return nil
	}
	return fmt.Errorf("unknown DetectionJobInstance field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DetectionJobInstanceMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.anomalies != nil {
		edges = append(edges, detectionjobinstance.EdgeAnomalies)
	}
	if m.detection_job != nil {
		edges = append(edges, detectionjobinstance.EdgeDetectionJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DetectionJobInstanceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case detectionjobinstance.EdgeAnomalies:
		ids := make([]ent.Value, 0, len(m.anomalies))
		for id := range m.anomalies {
			ids = append(ids, id)
		}
		return ids
	case detectionjobinstance.EdgeDetectionJob:
		if id := m.detection_job; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DetectionJobInstanceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedanomalies != nil {
		edges = append(edges, detectionjobinstance.EdgeAnomalies)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DetectionJobInstanceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case detectionjobinstance.EdgeAnomalies:
		ids := make([]ent.Value, 0, len(m.removedanomalies))
		for id := range m.removedanomalies {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DetectionJobInstanceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedanomalies {
		edges = append(edges, detectionjobinstance.EdgeAnomalies)
	}
	if m.cleareddetection_job {
		edges = append(edges, detectionjobinstance.EdgeDetectionJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DetectionJobInstanceMutation) EdgeCleared(name string) bool {
	switch name {
	case detectionjobinstance.EdgeAnomalies:
		return m.clearedanomalies
	case detectionjobinstance.EdgeDetectionJob:
		return m.cleareddetection_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DetectionJobInstanceMutation) ClearEdge(name string) error {
	switch name {
	case detectionjobinstance.EdgeDetectionJob:
		m.ClearDetectionJob()
		return nil
	}
	return fmt.Errorf("unknown DetectionJobInstance unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DetectionJobInstanceMutation) ResetEdge(name string) error {
	switch name {
	case detectionjobinstance.EdgeAnomalies:
		m.ResetAnomalies()
		return nil
	case detectionjobinstance.EdgeDetectionJob:
		m.ResetDetectionJob()
		return nil
	}
	return fmt.Errorf("unknown DetectionJobInstance edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op            Op
	typ           string
	id            *int
	create_time   *time.Time
	update_time   *time.Time
	username      *string
	email         *string
	password_hash *string
	service       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*User, error)
	predicates    []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID
// is only available if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCreateTime sets the "create_time" field.
func (m *UserMutation) SetCreateTime(t time.Time) {
	m.create_time = &t
}

// CreateTime returns the value of the "create_time" field in the mutation.
func (m *UserMutation) CreateTime() (r time.Time, exists bool) {
	v := m.create_time
	if v == nil {
		return
	}
	return *v, true
}

// OldCreateTime returns the old "create_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreateTime: %w", err)
	}
	return oldValue.CreateTime, nil
}

// ResetCreateTime resets all changes to the "create_time" field.
func (m *UserMutation) ResetCreateTime() {
	m.create_time = nil
}

// SetUpdateTime sets the "update_time" field.
func (m *UserMutation) SetUpdateTime(t time.Time) {
	m.update_time = &t
}

// UpdateTime returns the value of the "update_time" field in the mutation.
func (m *UserMutation) UpdateTime() (r time.Time, exists bool) {
	v := m.update_time
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdateTime returns the old "update_time" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUpdateTime is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUpdateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdateTime: %w", err)
	}
	return oldValue.UpdateTime, nil
}

// ResetUpdateTime resets all changes to the "update_time" field.
func (m *UserMutation) ResetUpdateTime() {
	m.update_time = nil
}

// SetUsername sets the "username" field.
func (m *UserMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *UserMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ResetUsername resets all changes to the "username" field.
func (m *UserMutation) ResetUsername() {
	m.username = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *UserMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *UserMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *UserMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetService sets the "service" field.
func (m *UserMutation) SetService(b bool) {
	m.service = &b
}

// Service returns the value of the "service" field in the mutation.
func (m *UserMutation) Service() (r bool, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldService(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *UserMutation) ResetService() {
	m.service = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.create_time != nil {
		fields = append(fields, user.FieldCreateTime)
	}
	if m.update_time != nil {
		fields = append(fields, user.FieldUpdateTime)
	}
	if m.username != nil {
		fields = append(fields, user.FieldUsername)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password_hash != nil {
		fields = append(fields, user.FieldPasswordHash)
	}
	if m.service != nil {
		fields = append(fields, user.FieldService)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreateTime:
		return m.CreateTime()
	case user.FieldUpdateTime:
		return m.UpdateTime()
	case user.FieldUsername:
		return m.Username()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPasswordHash:
		return m.PasswordHash()
	case user.FieldService:
		return m.Service()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreateTime:
		return m.OldCreateTime(ctx)
	case user.FieldUpdateTime:
		return m.OldUpdateTime(ctx)
	case user.FieldUsername:
		return m.OldUsername(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case user.FieldService:
		return m.OldService(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreateTime(v)
		return nil
	case user.FieldUpdateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdateTime(v)
		return nil
	case user.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case user.FieldService:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreateTime:
		m.ResetCreateTime()
		return nil
	case user.FieldUpdateTime:
		m.ResetUpdateTime()
		return nil
	case user.FieldUsername:
		m.ResetUsername()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case user.FieldService:
		m.ResetService()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown User edge %s", name)
}
